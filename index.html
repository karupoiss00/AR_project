<!DOCTYPE html>
<head>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>AR-TEST</title>
	<!-- include three.js library -->
	<script src='/AR/js/three.js'></script>
	<script src='/AR/js/OBJLoader.js'></script>
	<script src='/AR/js/MTLLoader.js'></script>
	<!-- include jsartookit -->
	<script src="/AR/jsartoolkit5/artoolkit.min.js"></script>
	<script src="/AR/jsartoolkit5/artoolkit.api.js"></script>
	<!-- include threex.artoolkit -->
	<script src="/AR/threex/threex-artoolkitsource.js"></script>
	<script src="/AR/threex/threex-artoolkitcontext.js"></script>
	<script src="/AR/threex/threex-arbasecontrols.js"></script>
	<script src="/AR/threex/threex-armarkercontrols.js"></script>
</head>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>

	<script>
		var scene, camera, renderer, clock, deltaTime, totalTime;
		var arToolkitSource, arToolkitContext;
		var markerRoot1;
		var mesh1;
		initialize();
		animate();
		function initialize()
		{
			scene = new THREE.Scene();
			let ambientLight = new THREE.AmbientLight( 0xcccccc, 1.0 );
			scene.add( ambientLight );
						
			camera = new THREE.Camera();
			scene.add(camera);
			renderer = new THREE.WebGLRenderer({
				antialias : true,
				alpha: true
			});
			renderer.setClearColor(new THREE.Color('lightgrey'), 0)
			renderer.setSize( 640, 480 );
			renderer.domElement.style.position = 'absolute'
			renderer.domElement.style.top = '0px'
			renderer.domElement.style.left = '0px'
			document.body.appendChild( renderer.domElement );
			clock = new THREE.Clock();
			deltaTime = 0;
			totalTime = 0;
			
			////////////////////////////////////////////////////////////
			// setup arToolkitSource
			////////////////////////////////////////////////////////////
			arToolkitSource = new THREEx.ArToolkitSource({
				sourceType : 'webcam',
			});
			function onResize()
			{
				arToolkitSource.onResize()	
				arToolkitSource.copySizeTo(renderer.domElement)	
				if ( arToolkitContext.arController !== null )
				{
					arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
				}	
			}
			arToolkitSource.init(function onReady(){
				onResize()
			});
			
			// handle resize event
			window.addEventListener('resize', function(){
				onResize()
			});
			
			////////////////////////////////////////////////////////////
			// setup arToolkitContext
			////////////////////////////////////////////////////////////	
			// create atToolkitContext
			arToolkitContext = new THREEx.ArToolkitContext({
				cameraParametersUrl: '/AR/data/camera_para.dat',
				detectionMode: 'mono'
			});
			
			// copy projection matrix to camera when initialization complete
			arToolkitContext.init( function onCompleted(){
				camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
			});
			////////////////////////////////////////////////////////////
			// setup markerRoots
			////////////////////////////////////////////////////////////
			// build markerControls
			markerRoot1 = new THREE.Group();
			scene.add(markerRoot1);
			let markerControls1 = new THREEx.ArMarkerControls(arToolkitContext, markerRoot1, {
				type: 'pattern', patternUrl: "/AR/data/hiro.patt",
			})


			function onProgress(xhr) { console.log( (xhr.loaded / xhr.total * 100) + '% loaded' ); }
			function onError(xhr) { alert( 'An error happened' ); }
/*
			var loader = new THREE.FontLoader();
			//loader.load( '/AR/fonts/helvetiker_regular.typeface.json', function ( font ) {

				/*var geometry = new THREE.TextBufferGeometry( 'Hello three.js!', {
					font: font,
					size: 80,
					height: 5,
					curveSegments: 12,
					bevelEnabled: true,
					bevelThickness: 10,
					bevelSize: 8,
					bevelOffset: 0,
					bevelSegments: 5
				} );*/

				/*var geometry = new THREE.TextGeometry( 'This is cat.', {
					font: font,
					size: 80,
					height: 1,
					curveSegments: 12,
				} );
				var material = new THREE.MeshBasicMaterial({
					color: 0xCC0000
				});
				var geometry = new THREE.BoxBufferGeometry( 1, 1, 1 );
				var texture = new THREE.TextureLoader().load( '/AR/images/water.jpg' );
				var material = new THREE.MeshBasicMaterial( { map: texture } );

				var textMesh = new THREE.Mesh(geometry, material);
				//textMesh.position.set(0, 0, 0);
				//textMesh.castShadow = true;
				textMesh.position.x = -0.2;
				textMesh.position.y = -0.2;
				textMesh.position.z = 0.5;

				markerRoot1.add(textMesh);
				alert("2")
			},  onProgress, onError );*/

			var loader = new THREE.TextureLoader();

			// load a resource
			loader.load(
					// resource URL
					'/AR/images/water.jpg',

					// onLoad callback
					function ( texture ) {
						var geometry = new THREE.BoxBufferGeometry( 1, 1, 1 );
						var material = new THREE.MeshBasicMaterial( { map: texture } );

						var textMesh = new THREE.Mesh(geometry, material);
						//textMesh.position.set(0, 0, 0);
						//textMesh.castShadow = true;
						textMesh.position.x = -0.2;
						textMesh.position.y = -0.2;
						textMesh.position.z = 0.5;

						markerRoot1.add(textMesh);
						alert("2")
					},

					// onProgress callback currently not supported
					undefined,

					// onError callback
					function ( err ) {
						console.error( 'An error happened.' );
					}
			);

			
			new THREE.MTLLoader()
				.setPath( '/AR/models/' )
				.load( 'cat.mtl', function ( materials ) {
					materials.preload();
					new THREE.OBJLoader()
						.setMaterials( materials )
						.setPath( '/AR/models/' )
						.load( 'cat.obj', function ( group ) {
							catMesh = group.children[0];
							catMesh.material.side = THREE.DoubleSide;
							catMesh.position.x = -0.2;
							catMesh.position.y = -0.2;
							catMesh.position.z = 0.5;
							catMesh.scale.set(0.02,0.02,0.02);
							//markerRoot1.add(catMesh);
						}, onProgress, onError );
				});
		}
		function update()
		{
			// update artoolkit on every frame
			if ( arToolkitSource.ready !== false )
				arToolkitContext.update( arToolkitSource.domElement );
		}
		function render()
		{
			renderer.render( scene, camera );
		}
		function animate()
		{
			requestAnimationFrame(animate);
			deltaTime = clock.getDelta();
			totalTime += deltaTime;
			update();
			render();
		}
	</script>

</body>
</html>